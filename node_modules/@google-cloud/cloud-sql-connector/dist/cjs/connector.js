"use strict";
// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
Object.defineProperty(exports, "__esModule", { value: true });
exports.Connector = void 0;
const cloud_sql_instance_1 = require("./cloud-sql-instance");
const socket_1 = require("./socket");
const ip_addresses_1 = require("./ip-addresses");
const auth_types_1 = require("./auth-types");
const sqladmin_fetcher_1 = require("./sqladmin-fetcher");
const errors_1 = require("./errors");
// Internal mapping of the CloudSQLInstances that
// adds extra logic to async initialize items.
class CloudSQLInstanceMap extends Map {
    async loadInstance({ ipType, authType, instanceConnectionName, sqlAdminFetcher, }) {
        // in case an instance to that connection name has already
        // been setup there's no need to set it up again
        if (this.has(instanceConnectionName)) {
            const instance = this.get(instanceConnectionName);
            if (instance.ipType && instance.ipType !== ipType) {
                throw new errors_1.CloudSQLConnectorError({
                    message: `getOptions called for instance ${instanceConnectionName} with ipType ${ipType}, ` +
                        `but was previously called with ipType ${instance.ipType}. ` +
                        'If you require both for your use case, please use a new connector object.',
                    code: 'EMISMATCHIPTYPE',
                });
            }
            else if (instance.authType && instance.authType !== authType) {
                throw new errors_1.CloudSQLConnectorError({
                    message: `getOptions called for instance ${instanceConnectionName} with authType ${authType}, ` +
                        `but was previously called with authType ${instance.authType}. ` +
                        'If you require both for your use case, please use a new connector object.',
                    code: 'EMISMATCHAUTHTYPE',
                });
            }
            return;
        }
        const connectionInstance = await cloud_sql_instance_1.CloudSQLInstance.getCloudSQLInstance({
            ipType,
            authType,
            instanceConnectionName,
            sqlAdminFetcher: sqlAdminFetcher,
        });
        this.set(instanceConnectionName, connectionInstance);
    }
    getInstance({ instanceConnectionName, ipType, authType, }) {
        const connectionInstance = this.get(instanceConnectionName);
        if (!connectionInstance) {
            throw new errors_1.CloudSQLConnectorError({
                message: `Cannot find info for instance: ${instanceConnectionName}`,
                code: 'ENOINSTANCEINFO',
            });
        }
        else if (connectionInstance.ipType &&
            connectionInstance.ipType !== ipType) {
            throw new errors_1.CloudSQLConnectorError({
                message: `getOptions called for instance ${instanceConnectionName} with ipType ${ipType}, ` +
                    `but was previously called with ipType ${connectionInstance.ipType}. ` +
                    'If you require both for your use case, please use a new connector object.',
                code: 'EMISMATCHIPTYPE',
            });
        }
        else if (connectionInstance.authType &&
            connectionInstance.authType !== authType) {
            throw new errors_1.CloudSQLConnectorError({
                message: `getOptions called for instance ${instanceConnectionName} with authType ${authType}, ` +
                    `but was previously called with authType ${connectionInstance.authType}. ` +
                    'If you require both for your use case, please use a new connector object.',
                code: 'EMISMATCHAUTHTYPE',
            });
        }
        return connectionInstance;
    }
}
// The Connector class is the main public API to interact
// with the Cloud SQL Node.js Connector.
class Connector {
    constructor(opts = {}) {
        this.instances = new CloudSQLInstanceMap();
        this.sqlAdminFetcher = new sqladmin_fetcher_1.SQLAdminFetcher({
            loginAuth: opts.auth,
            sqlAdminAPIEndpoint: opts.sqlAdminAPIEndpoint,
        });
    }
    // Connector.getOptions is a method that accepts a Cloud SQL instance
    // connection name along with the connection type and returns an object
    // that can be used to configure a driver to be used with Cloud SQL. e.g:
    //
    // const connector = new Connector()
    // const opts = await connector.getOptions({
    //   ipType: 'PUBLIC',
    //   instanceConnectionName: 'PROJECT:REGION:INSTANCE',
    // });
    // const pool = new Pool(opts)
    // const res = await pool.query('SELECT * FROM pg_catalog.pg_tables;')
    async getOptions({ authType = auth_types_1.AuthTypes.PASSWORD, ipType = ip_addresses_1.IpAddressTypes.PUBLIC, instanceConnectionName, }) {
        const { instances } = this;
        await instances.loadInstance({
            ipType,
            authType,
            instanceConnectionName,
            sqlAdminFetcher: this.sqlAdminFetcher,
        });
        return {
            stream() {
                const cloudSqlInstance = instances.getInstance({
                    instanceConnectionName,
                    ipType,
                    authType,
                });
                const { instanceInfo, ephemeralCert, host, port, privateKey, serverCaCert, } = cloudSqlInstance;
                if (instanceInfo &&
                    ephemeralCert &&
                    host &&
                    port &&
                    privateKey &&
                    serverCaCert) {
                    const tlsSocket = (0, socket_1.getSocket)({
                        instanceInfo,
                        ephemeralCert,
                        host,
                        port,
                        privateKey,
                        serverCaCert,
                    });
                    tlsSocket.once('error', async () => {
                        await cloudSqlInstance.forceRefresh();
                    });
                    tlsSocket.once('secureConnect', async () => {
                        cloudSqlInstance.setEstablishedConnection();
                    });
                    return tlsSocket;
                }
                throw new errors_1.CloudSQLConnectorError({
                    message: 'Invalid Cloud SQL Instance info',
                    code: 'EBADINSTANCEINFO',
                });
            },
        };
    }
    async getTediousOptions({ authType, ipType, instanceConnectionName, }) {
        if (authType === auth_types_1.AuthTypes.IAM) {
            throw new errors_1.CloudSQLConnectorError({
                message: 'Tedious does not support Auto IAM DB Authentication',
                code: 'ENOIAM',
            });
        }
        const driverOptions = await this.getOptions({
            authType,
            ipType,
            instanceConnectionName,
        });
        return {
            async connector() {
                return driverOptions.stream();
            },
            // note: the connector handles a secured encrypted connection
            // with that in mind, the driver encryption is disabled here
            encrypt: false,
        };
    }
    // clear up the event loop from the internal cloud sql
    // instances timeout callbacks that refresh instance info
    close() {
        for (const instance of this.instances.values()) {
            instance.cancelRefresh();
        }
    }
}
exports.Connector = Connector;
//# sourceMappingURL=connector.js.map